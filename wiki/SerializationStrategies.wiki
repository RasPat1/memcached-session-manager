#summary This page gives an overview over available (pluggable) serialization strategies with their pro's and con's.

_(still work in progress)_

= Introduction =
By default memcached-session-manager uses Java's serialization to serialize session data so that it can be sent to memcached. The same applies to deserialization of course.

As Java's serialization has some limitations/disadvantages, the serialization strategy can be changed and replaced by alternative ones. However, Java serialization also brings in some useful stuff, which should not get lost with other serialization strategies.


= Features of serialization strategies =
The following features should be provided by all serialization strategies, as they are related to correct behavior of either the serialization-/deserialization process or the deserialized objects compared to the original ones.

  * *Serialization: Handle cyclic dependencies.* Cyclic dependencies may occur in an object graph and therefor should be supported. The solution is to additionally store ids for serialized objects and refids to already serialized objects if it's found again.
  * *Serialization/Deserialization: Support references to a shared object.* If two instances A and B share the same reference to a shared object C this must be the same for the deserialized objects. As the solution is the same as for cyclic dependencies, both features are fairly related.
  * *Deserialization: Support private classes.* During deserialization private classes are a challange, as even the Class object is not visible and therefore you cannot dynamically create an instance of such a class.
  * *Deserialization: Support classes without default constructor.* If a class does not provide a default constructor (a constructor without any arguments), you don't know how to create a new instance of this class.


= Available serialization strategies =
This is a list of available serialization strategies and their features.

|| *Serialization Strategy* || *Requires <br/> `java.io.Serializable`* || *Cyclic <br/> Dependencies* || *Shared <br/> objects* || *Private classes* || *Classes without <br/> default constructor* || *Comment* ||
|| *java serialization* (default) <br/> `de.javakaffee.web.msm.SessionSerializingTranscoderFactory` || Yes || Yes || Yes || Yes || Yes ||
|| *msm-javolution-serializer* <br/> `de.javakaffee.web.msm.serializer.javolution.JavolutionTranscoderFactory` || No || Yes || Yes || Yes (for Sun JVMs) || Yes (for Sun JVMs) ||
|| *msm-xstream-serializer* <br/> `de.javakaffee.web.msm.serializer.xstream.XStreamTranscoderFactory` || No || Yes || Yes || Yes (see also [http://xstream.codehaus.org/faq.html#Compatibility_JVMs XStream FAQ]) || Yes (see also [http://xstream.codehaus.org/faq.html#Compatibility_JVMs XStream FAQ]) ||


= Pro's/Con's of Java's serialization =
What's good/bad with java's serialization related to the usage with the msm?

  * *PRO: handles cyclic dependencies.*
  * *PRO: supports private classes.* During deserialization private classes are a challange, as even the Class object is not visible and therefore you cannot dynamically create an instance of such a class.
  * *PRO: supports classes without default constructor.* If a class does not provide a default constructor (a constructor without any arguments), you don't know how to create a new instance of this class.
  * ... more, less?

  * *CON: classes to be serialized need to implement `java.io.Serializable`.* Unfortunately you don't have always the code at your hand that shall get serialized.
  * *CON: no support for different versions of the same class.* All clients reading the serialized content need to have exactly the same version of the compiled class.
  * *CON: the serialised files are not human readable.* If you want to inspect the serialized content e.g. because you want to see if things can be optimized somehow, you cannot just look at what got serialized.
  * ... more, less?


= Want to roll your own? =
This section shall outline, which feature a serialization protocol should provide so that it can be used for a serialization strategy for the memcached-session-manager.


  * *Serialization of dynamic structures.* This requirement is a result from an asumption, that users shall not be forced to provide s.th. like a schema for their session objects. Most of the time, users even don't know really, what gets stored in the http session and what not. Therefore it's rather impossible to provide a structural definition of the session attributes. However, if this asumption is wrong, serialization of dynamic structures is no longer a requirement :)
  * *Recreate appropriate types during deserialization.* As session attributes are just bound to a name, that type information for the attribute values must be stored by the serialization protocal. That's the reason, why JSON is (unfortunately) not an appropriate serialization protocol for the memcached-session-manager. One would need to implement a custom JSON format (and I would be happy, if Jackson would/could do this).