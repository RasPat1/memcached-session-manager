#summary This page shows what's necessary to get the memcached-session-manager up and running.
#labels Featured,Phase-Deploy

= Introduction =

For the most simple integration you just need to have a tomcat (6 or 7) and a memcached installed (or s.th. supporting the memcached protocol).
In your production environment you probably will have several tomcats and you should also have several memcached nodes available, on different pieces of hardware. You can use sticky sessions or non-sticky sessions, memcached-session-manager supports both operation modes.

The following description shows an example for a setup with sticky sessions, with two instances of tomcat and two instances of memcached installed.

Tomcat-1 (t1) will primarily store it's sessions in memcached-2 (m2) which is running on another machine (m2 is a regular node for t1). Only if m2 is not available, t1 will store it's sessions in memcached-1 (m1, m1 is the failoverNode for t1). With this configuration, sessions won't be lost when machine 1 (serving t1 and m1) crashes. The following really nice ASCII art shows this setup.

{{{
<t1>   <t2>
  . \ / .
  .  X  .
  . / \ .
<m1>   <m2>
}}}

= Details =

So what needs to be done for this?

== Decide which serialization strategy to use ==
Starting with release 1.1 there are several session serialization strategies available, as they are described on SerializationStrategies. The default strategy uses java serialization and is already provided by the memcached-session-manager jar. Other strategies are provided by separate jars, in the section below you'll see which jars are required for which strategy.

== Configure tomcat ==
The configuration of tomcat requires two things: you need to drop some jars in your {{{$CATALINA_HOME/lib/}}} and {{{WEB-INF/lib/}}} directories and you have to configure the memcached session manager in the related {{{<Context>}}} element (e.g. in {{{$CATALINA_HOME/conf/context.xml}}}).

=== Add jars to {{{$CATALINA_HOME/lib/}}} ===
Independent of the chosen serialization strategy you always need the [http://memcached-session-manager.googlecode.com/files/memcached-session-manager-1.4.0.jar memcached-session-manager-1.4.0.jar] (for tomcat6, or [http://memcached-session-manager.googlecode.com/files/memcached-session-manager-tc7-1.4.0.jar memcached-session-manager-tc7-1.4.0.jar] for tomcat7) and the [http://spymemcached.googlecode.com/files/memcached-2.5.jar memcached-2.5.jar] (spymemcached). Just download and put them in {{{$CATALINA_HOME/lib/}}}.

=== Add jars to {{{WEB-INF/lib/}}} ===
If you want to use java's built in serialization nothing more has to be done.
If you want to use a custom serialization strategy (e.g. because of [SerializationStrategyBenchmark better performance]) you need to drop some jars into your projects {{{WEB-INF/lib/}}} directory. In the following the jars are listed by serialization strategy.
  * For *kryo based serialization* (recommended) these jars are required additionally (in your {{{WEB-INF/lib}}}):
    * [http://memcached-session-manager.googlecode.com/files/kryo-1.03.jar kryo-1.03.jar]
    * [http://memcached-session-manager.googlecode.com/files/minlog-1.2.jar minlog-1.2.jar]
    * [http://memcached-session-manager.googlecode.com/files/reflectasm-0.9.jar reflectasm-0.9.jar]
    * [http://mirrors.ibiblio.org/pub/mirrors/maven2/asm/asm/3.2/asm-3.2.jar asm-3.2.jar]
    * [http://github.com/downloads/magro/kryo-serializers/kryo-serializers-0.8.jar kryo-serializers-0.8.jar]
    * [http://memcached-session-manager.googlecode.com/files/msm-kryo-serializer-1.4.0.jar msm-kryo-serializer-1.4.0.jar]
  * For *javolution based serialization* these jars are required additionally:
    * [http://memcached-session-manager.googlecode.com/files/javolution-5.4.3.1.jar javolution-5.4.3.1.jar] (a patched version of the latest javolution release, the patch is required to support serialization of jdk proxies)
    * [http://memcached-session-manager.googlecode.com/files/msm-javolution-serializer-1.4.0.jar msm-javolution-serializer-1.4.0.jar]
  * For *xstream based serialization* these jars are required additionally:
    * [http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar xstream-1.3.1.jar]
    * [http://www.extreme.indiana.edu/dist/java-repository/xpp3/jars/xpp3_min-1.1.3.4.O.jar xpp3_min-1.1.3.4.O.jar] (xml pull parser used by xstream)
    * [http://memcached-session-manager.googlecode.com/files/msm-xstream-serializer-1.4.0.jar msm-xstream-serializer-1.4.0.jar]

=== Configure {{{<Context>}}} element with memcached-session-manager ===
Update the {{{<Context>}}} element (in {{{$CATALINA_HOME/conf/context.xml}}} or what else you choose for context definition, please check the related [http://tomcat.apache.org/tomcat-7.0-doc/config/context.html#Defining_a_context tomcat documentation] for this) so that it contains the {{{Manager}}} configuration for the memcached-session-manager, like this example for sticky sessions:
{{{
<Context>
  ...
  <Manager className="de.javakaffee.web.msm.MemcachedBackupSessionManager"
    memcachedNodes="n1:localhost:11211 n2:localhost:11212"
    failoverNodes="n1"
    requestUriIgnorePattern=".*\.(ico|png|gif|jpg|css|js)$"
    transcoderFactoryClass="de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"
    />
</Context>
}}}

For non-sticky sessions the configuration would look like this:
{{{
<Context>
  ...
  <Manager className="de.javakaffee.web.msm.MemcachedBackupSessionManager"
    memcachedNodes="n1:localhost:11211 n2:localhost:11212"
    sticky="false"
    lockingMode="uriPattern:/path1|/path2"
    requestUriIgnorePattern=".*\.(ico|png|gif|jpg|css|js)$"
    transcoderFactoryClass="de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"
    />
</Context>
}}}

These example configurations assume, that you have running two memcached nodes on localhost, one on port 11211 and another one on port 11212, and that you want to use kryo based serialization. More details to configuration attributes are provided in the section below.

Now you have finished the configuration of your first tomcat. For the second tomcat you just need to change the failover node when you're using sticky sessions.

After this is done, you can just start your application and sessions will be stored in the configured memcached nodes as configured. Now you should do some tests with a simulated tomcat failure, a restart of a memcached node etc. - have fun! :-)

=== !MemcachedBackupSessionManager configuration attributes ===

_className_ (required)
  This should be set to {{{de.javakaffee.web.msm.MemcachedBackupSessionManager}}} to get sessions stored in memcached. However, since version 1.3.6 there's also a {{{de.javakaffee.web.msm.DummyMemcachedBackupSessionManager}}} that can be used for development purposes: it simply serializes sessions to a special in memory map and deserializes the serialized data at the next request when a session is requested (without really using this session) - just to see if deserialization is working for each request. Your application is still using sessions as if the memcached-session-manager (or !DummyMemcachedBackupSessionManager) would not be existing. Session serialization/deserialization is done asynchronously.
  The configuration attributes {{{memcachedNodes}}} and {{{failoverNode}}} are not used to create a memcached client, so serialized session data will *not* be sent to memcached - and therefore no running memcacheds are required.

_memcachedNodes_ (required)
  This attribute must contain all memcached nodes you have running. Each memcached node is defined as {{{<id>:<host>:<port>}}}. Several definitions are separated by space or comma.

_failoverNodes_ (optional, must not be used for non-sticky sessions)
 This attribute must contain the ids of the memcached nodes, that shall not be used by this tomcat for session backup, but only if no other memcached nodes are available. Therefore, you should list those memcached nodes, that are running on the same machine as this tomcat. Several memcached node ids are separated by space or comma. For non-sticky sessions failoverNodes must not be specified as a session is not tied to a single tomcat.

_memcachedProtocol_ (since 1.3, optional, default _text_)
  This attribute specifies the memcached protocol to use, one of _text_ or _binary_.

_sticky_ (since 1.4.0, optional, default _true_)
 Specifies if sticky or non-sticky sessions are used.

_lockingMode_ (since 1.4.0, optional, for non-sticky sessions only, default _none_)
 Specifies the locking strategy for non-sticky sessions. Session locking is useful to prevent concurrent modifications and lost updates of the session in the case of parallel requests (tabbed browsing with long requests, ajax etc.). Session locking is done using memcached. Possible values for {{{lockingMode}}} are:
  ** {{{none}}}: sessions are never locked
  ** {{{all}}}: the session is locked when requested by the app until the end of the request
  ** {{{auto}}}: readonly requests are detected, for them the session is not locked. For requests that are not classified as "readonly" the session is locked
  ** {{{uriPattern:<regexp>}}}: the provided [http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html regular expression pattern] is compared with the {{{requestURI}}} + "?" + {{{queryString}}} and the session is locked if they match.

_requestUriIgnorePattern_ (optional)
 This attribute contains a regular expression for request URIs, that shall not trigger a session backup. If static resources like css, javascript, images etc. are delivered by the same tomcat and the same web application context these requests will also pass the memcached-session-manager. However, as these requests should not change anything in a http session, they should also not trigger a session backup. So you should check if any static resources are delivered by tomcat and in this case you should exclude them by using this attribute. The {{{requestUriIgnorePattern}}} must follow the java regex [http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html Pattern].

_sessionBackupAsync_ (optional, default _true_)
 Specifies if the session shall be stored asynchronously in memcached. If this is _true_, the _backupThreadCount_ setting is evaluated. If this is _false_, the timeout set via _sessionBackupTimeout_ is evaluated.

_backupThreadCount_ (since 1.3, optional, default _number-of-cpu-cores_)
 The number of threads that are used for asynchronous session backup (if _sessionBackupAsync="true"_). For the default value the number of available processors (cores) is used.

_sessionBackupTimeout_ (optional, default _100_)
 The timeout in milliseconds after that a session backup is considered as beeing failed. This property is only evaluated if sessions are stored synchronously (set via _sessionBackupAsync_). The default value is _100_ milliseconds.

_transcoderFactoryClass_ (since 1.1, optional, default _de.javakaffee.web.msm.!JavaSerializationTranscoderFactory_)
 The class name of the factory that creates the transcoder to use for serializing/deserializing sessions to/from memcached. The specified class must implement {{{de.javakaffee.web.msm.TranscoderFactory}}} and provide a no-args constructor. Other {{{TranscoderFactory}}} implementations are available through other packages/jars like _msm-kryo-serializer_, _msm-xstream-serializer_ and _msm-javolution-serializer_ (as describe above), those are listed and compared on SerializationStrategies.

 Available {{{TranscoderFactory}}} implementations:<br/>
  ** Java serialization: {{{de.javakaffee.web.msm.JavaSerializationTranscoderFactory}}}
  ** [http://code.google.com/p/kryo/ Kryo] based serialization: {{{de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory}}}
  ** Javolution based serialization: {{{de.javakaffee.web.msm.serializer.javolution.JavolutionTranscoderFactory}}}
  ** XStream based serialization: {{{de.javakaffee.web.msm.serializer.xstream.XStreamTranscoderFactory}}}

_copyCollectionsForSerialization_ (since 1.1, optional, default _false_)
 A boolean value that specifies, if iterating over collection elements shall be done on a copy of the collection or on the collection itself. This configuration property must be supported by the serialization strategy specified with _transcoderFactoryClass_. Which strategy supports this feature can be seen in the column _Copy Collections before serialization_ in the list of  [SerializationStrategies#Available_serialization_strategies available serialization strategies]. This feature and its motivation is described more deeply at [SerializationStrategies#Concurrent_modifications_of_collections].

_customConverter_ (since 1.2, optional)
 Custom converter allow you to provide custom serialization of application specific types. Multiple custom converter class names are specified separated by comma (with optional space following the comma). Converter classes must be available in the classpath of the web application (place jars in {{{WEB-INF/lib}}}).<br/>
 This option is useful if you need some special serialization for a certain type or if reflection based serialization is just very verbose and you want to provide a more efficient serialization for a specific type.<br/>
 Custom converter must be supported by the serialization strategy specified with _transcoderFactoryClass_. Requirements regarding the specific custom converter classes depend on the actual serialization strategy, but a common requirement would be that they must provide a default/no-args constructor. For more details have a look at [SerializationStrategies#Available_serialization_strategies available serialization strategies].

 Available converter implementations:<br/>
  ** Kryo (converters provided by msm-kryo-serializer jar)
    ** {{{de.javakaffee.web.msm.serializer.kryo.JodaDateTimeRegistration}}}: A more efficient serialization of Joda's [http://joda-time.sourceforge.net/api-release/index.html?org/joda/time/DateTime.html DateTime] with kryo.
    ** {{{de.javakaffee.web.msm.serializer.kryo.CGLibProxySerializerFactory}}}: serializes/deserializes CGLIB proxies.
    ** {{{de.javakaffee.web.msm.serializer.kryo.HibernateCollectionsSerializerFactory}}}: serializes/deserializes hibernate persistent collections (required if you store collections loaded by hibernate in your session).
    ** {{{de.javakaffee.web.msm.serializer.kryo.WicketSerializerFactory}}}: required if you're running a wicket web application.
  ** Javolution (converters provided by msm-javolution-serializer jar)
    ** {{{de.javakaffee.web.msm.serializer.javolution.JodaDateTimeFormat}}}: A more efficient serialization of Joda's [http://joda-time.sourceforge.net/api-release/index.html?org/joda/time/DateTime.html DateTime], see also [http://code.google.com/p/memcached-session-manager/issues/detail?id=32 issue #32].
    ** {{{de.javakaffee.web.msm.serializer.javolution.CGLibProxyFormat}}} : serializes/deserializes CGLIB proxies, see also [http://code.google.com/p/memcached-session-manager/issues/detail?id=59 issue #59].
    ** {{{de.javakaffee.web.msm.serializer.javolution.HibernateCollectionsXMLFormat}}}: serializes/deserializes hibernate persistent collections (required if you store collections loaded by hibernate in your session).

_enableStatistics_ (since 1.2, optional, default _true_)
 A boolean value that specifies, if statistics shall be gathered. For more info see the [JMXStatistics] page.

_enabled_ (since 1.4.0, optional, default _true_)
 Specifies if session storage in memcached is enabled or not, can also be changed at runtime via JMX. Only allowed in sticky mode.<br/>
<br/>

== Logging ==
If you want to enable fine grained / debug logging you can add

{{{
de.javakaffee.web.msm.level=FINE
}}}

to `$CATALINA_HOME/conf/logging.properties`.

As the memcached-session-manager uses [http://code.google.com/p/spymemcached/ spymemcached] also the [http://code.google.com/p/spymemcached/wiki/Logging logging hints of spymemcached] might be interesting to you.